<meta charset="utf-8" lang="en">  <!-- this line allows UTF-8 characters in the .html file -->

                    **L01_FindTheOne**



Author
=============


<div class="noheader firstcol">
                  |             
------------------|-------------
name              | Rose White
computer + OS     | Windows 10 Laptop
time to complete  | 2 hours
partner           | Courtney Masters
additional help   | Dr. Denning
</div>






Implementations
===================


`Neo_Up` Implementation
--------------------------

I went for the binary search approach to find "the one". I implemented it as normal, however I came
across a bug in the while loop. I used "&&" statements to check if neo.get(i) did NOT meet all of the conditions I
needed to find the first 1. It never met the qualifications since I used "AND" statements, but Dr. Denning suggested
I use OR statements instead, which made it work great!

I checked that it was correct by testing it and making sure I received a low number of get calls.

`Neo_Down` Implementation
--------------------------

For this one we also used the binary search, using Integer.MAX_VALUE as our upper bound. However, we ran into a bug
when finding the midpoint. We added low to high and then divided both by two. Dr. Denning explained how even though that
made sense mathematically, the computer was halving the lower bound and upper bound before adding the two, which
resulted in weird negative numbers. So we changed it to "low+((high-low)/2)" to clearly tell the computer what we want.

We checked that it was correct by testing it and making sure we received a low number of get calls.

`Neo_Left` Implementation
--------------------------


`Neo_Right` Implementation
---------------------------


Known bugs / limitations
-------------------------


Bugs with each implementation are explained in their write-ups.

We checked for additional bugs by running each implementation with different seed numbers.


Reflection
===========

All of my help was received from Dr. Denning. My friend Courtney and I discussed this problem by explaining the algorithm
out loud and then implementing it/changing it through trial and error. We also looked at print out results to see what
the computer was seeing at each step of the process.


Overall this was a fun, challenging lab that helped me understand binary search more. If I had more time I would
definitely reduce my get calls by assigning the neo.get(i) to a variable to not call it more than needed.






<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
body {font-family:'Open Sans',sans-serif;}
.md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
.md table.table th {background-color:hsl(252,23.0%,44.3%);}
.md .noheader th {display:none;}
.md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
.md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible");</script>
